# https://www.acmicpc.net/problem/2178

'''
N×M크기의 배열로 표현되는 미로가 있다.

1	0	1	1	1	1
1	0	1	0	1	0
1	0	1	0	1	1
1	1	1	0	1	1
미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

입력                출력
4 6                 15
101111
101010
101011
111011
'''

'''
풀이 첫번째 아이디어
101은 길이 끊긴것을 의미, 111은 길이 이어진것을 의미하므로,
이어져 있는 길로 계속해서 나아가는것이 중요
가까운 인접 노드들을 계속해서 나아가는 것이므로, 너비우선 탐색을 해야함
'''

n, m = map(int, input().split())  # 행렬에 대한 정보를 입력받는다.
count = 0

graph = []
for i in range(n):
    graph.append([])  # 행의 개수만큼 정점 집합을 생성한다.

for i in range(n):
    row = input()  # 한 행에 대한 정보를 입력받고, 정보에 따라서 분류를 시작
    for j in range(len(row)):
        graph[i].append(int(row[j]))
        # if row[j] == '1':  # 해당 루트가 갈수 있는 경로라면 그래프에 표히
        #    graph[i].append(j)  # i정점에서 j정점으로 갈수있는지에 대한 정보 표시
        #   graph[j].append(i)

# 오른쪽 아래로 향하는것이 목표이므로
# 일반적인 상황을 가정하면 오른쪽으로 갈수 있는길이 있는지 파악하고, 길이 없다면 아래쪽 길을 확인하는 과정을 거쳐서
# 계속 해당 위치로 나아가는 과정을 거치면 목적지에 도착할 수 있을것이다
# 한번 나아간 길은 지나갔다는 표시를 해주는 것이 좋을것같고
# 나아간 길이 막다른 길이라면 다시 이전 길로 돌아가는 과정이 필요할것이다.
for i in range(n):
    for j in range(n):
        if graph[i][j] == 1:
            count += 1
        else:  # 0을 마주친 경우, 즉 벽을 마주친 경우엔 인접한 정점들 중 갈수있는 노드가 어디인지 파악한다.
            continue  # 해당 루트

# row = input()
# print(row)

# print(graph)
