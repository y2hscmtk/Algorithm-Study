# https://www.acmicpc.net/problem/1520
'''
4가지 방향을 종합적으로 파악해야하므로 오르막 길에서 처럼 코드를 작성한다면 모든 방향에 대한 누적 값을 얻을 수 없다.
재귀 호출을 통해 4가지 방향에 대한 조건을 만족하는 모든 경로의 수를 끌어 모은다.
dp테이블과 dfs를 항상 복합적으로 생각한다.
일반적으로 dfs를 수행한다면 이미 수행한 결과에 대해서 한번 더 수행할 수 있으므로
더이상 수행할 필요가 없다고 판단된다면 dp테이블을 활용하여 한번만 수행하도록 한다.
dp[i][j] = (1,1)에서 (i,j)까지 조건을 만족하며 갈 수 있는 모든 경우의 수의 합
범위 초과를 편하게 방지하기 위해 테투리에 값이 0인 패딩을 준다.(내리막 수 조건에 의해 0에서 어떤 수로도 이동 할 수 없게 된다.)
'''
import sys
input = sys.stdin.readline
n,m = map(int,input().split())
arr = [[0]*(m+2)] +[[0]+list(map(int,input().split()))+[0] for _ in range(n)] + [[0]*(m+2)]
dp = [[-1]*(m+2) for _ in range(n+2)] # dp가 -1이라는 의미는 아직 탐색하지 않은 값이라는 의미
dp[1][1] = 1 # 탐색 시작 위치로 이동할 수 있는 경우의 수는 항상 1 => 초기값
def dfs(x,y):
    if dp[x][y] == -1: # 아직 탐색하지 않는 위치라면
        dp[x][y] = 0 # 탐색 처리 + 값 초기화(방법의 수를 누적해서 더하기 위해 0으로 초기화)
        # 상하좌우로 이동하여 조건에 맞는 방법의 수 끌어 모으기
        for dx,dy in ((1,0),(-1,0),(0,1),(0,-1)):
            nx,ny = x+dx,y+dy
            # 이동하려는 위치의 값이 현재 값보다 큰 값인지 확인(내리막 길인지 확인)
            # => 0으로 둘러싼 패딩에 대해서는 dfs가 수행되지 않음(조건식에 의해)
            if arr[nx][ny] > arr[x][y]:
                dp[x][y] += dfs(nx,ny) # 값 누적
    return dp[x][y]

print(dfs(n,m))
