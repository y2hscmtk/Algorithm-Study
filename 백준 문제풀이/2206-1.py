# https://www.acmicpc.net/problem/2206]

'''
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.

만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.

한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.
'''
'''
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.

출력
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.
'''
# 2206번 두번째 시도(풀이 참고)
# https://tmdrl5779.tistory.com/15
# 기존 풀이의 실패의 원인 : 시간복잡도 문제 => 같은 구간에 대한 bfs를 중복으로 시행하였기떄문
# 즉, 벽이 없는 부분에 대해서는 이미 결정된 문제이기 때문에 탐색을 하지 않아도 됨에도 불구하고, 브루트포스방식으로 문제를 해결하려고 했기 때문에
# 따라서 기존에 벽을 부쉈는지 안부쉈는지에 대한 정보만 전달할수 있다면, 굳이 모든 경우에 대해 bfs를 시행할 필요없이 벽을 마주쳤을때에 대해서만 조건을 달리하면된다
# 기존에 벽을 부수지 않은 상태에서 벽을 만났을때는 벽을 부수고, 빈공간을 만나면 거리를 누적시키며 지나간다.
# 벽을 부순 상태에서 벽을 만나면 지나갈수 없고, 빈공간을 만나면 지나간다.
# 위 과정을 통해, 길이 나누어 지더라도 이전에 벽을 부쉈는지 아닌지에 대한 정보가 누적되므로, 목적지까지 도달할수 있게된다.

from collections import deque
n, m = map(int, input().split())
# 맵 정보 입력받기
graph = [list(map(int, input())) for i in range(n)]

# 벽을 부쉈는지 부수지 않았는지에 대해 기록해둘 3차원 배열
# visited[][][1]은 벽을 부수고 갔을때의 최단경로
# visited[][][0]은 벽을 부수지 않고 갔을때의 최단경로
visited = [[[0] * 2 for _ in range(m)] for _ in range(n)]

# 방향 벡터
dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

# bfs


def bfs():
    queue = deque()
    queue.append([0, 0, 0])  # 0,0에서 bfs 시작 마지막 0은 벽을 부수지 않았음을 의미
    visited[0][0][0] = 1
    # 이전에 벽을 부쉈다면 crash = 1
    # 이전에 벽을 부수지 않았다면 crash = 0이다.
    # visited[][][crash]의 값을 수정한다.
    while queue:
        x, y, crash = queue.popleft()
        # 목적지에 도달하면 bfs 종료
        if x == n-1 and y == m-1:
            return visited[x][y][crash]
        # 상하좌우 방향에 대해 탐색 진행
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            # 배열의 범위를 벗어나지 않는 좌표에 대해서
            if 0 <= nx < n and 0 <= ny < m:
                # 그래프의 좌표가 벽이 아니고, 아직 방문한적 없을때
                if graph[nx][ny] == 0 and visited[nx][ny][crash] == 0:
                    # 벽을 부수지않은 상태를 유지하면서, 해당정보를 기록하는 배열의 값을 누적한다.
                    visited[nx][ny][crash] = visited[x][y][crash] + 1  # 방문처리
                    queue.append([nx, ny, crash])
                # 벽을 만났고, 아직 벽을 부순적이 없다면
                if graph[nx][ny] == 1 and crash == 0:
                    # 벽을 부수고 가는 경우에 대한 배열에
                    # 벽을 부쉈을때의 최단경로를 기록한다.
                    visited[nx][ny][1] = visited[x][y][crash] + 1
                    queue.append([nx, ny, 1])  # 벽을 부쉈다는 정보를 큐에 넘겨준다.

    return -1  # 목적지에 도달하지 못했을경우 -1


print(bfs())
