# https://www.acmicpc.net/problem/10844

'''
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.
'''

# 핵심은 좌우의 수의 차이가 1이라는 점, 그리고 0으로 시작하지 않는다는 점

n = int(input())

# 앞자리 수가 i인 n자리 계단수의 개수는 다음과 같이 표현한다
# dp[n][i]
# 이때 i는 1~9까지 가능함

# 수를 저장할 2차원 배열 작성
# n은 1보다 크고 100보다 작거나 같은 수
dp = [[0]*10 for _ in range(101)]

# 한자리 계단 수의 개수 기록
for i in range(1, 10):
    dp[1][i] = 1

# 알고리즘 수행

# n자리 수가 될때까지 계단수 dp테이블에 작성
for i in range(2, n+1):  # 3~n자리 계단수 계산
    # 앞자리수가 될 수 있는 조건은 1~9까지의 수 => i에 대입하여 기록
    # 다음 수의 계산을 위해 앞자리수가 0인 계단수도 기록은 해둔다.
    for j in range(10):
        # 앞자리수가 0인 경위와 9인 경우는 뒤의수가 1과 8만이 가능하므로 별도로 기록한다.
        if j == 0:
            dp[i][j] = dp[i-1][1]  # 1인 경우만 가능
        elif j == 9:
            dp[i][j] = dp[i-1][8]  # 8인 경우만 가능
        else:
            # 2인 경우 1과 3이 가능(+-1인 쌍이 존재) => 오버플로우 방지를 위하여 %1000000000 하여 저장
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

# 결과 출력 n자리 계단수들의 합 => 앞자리 수가 0인 경우는 계단수로 취급하지 않으므로 빼준다.
print((sum(dp[n])-dp[n][0]) % 1000000000)
