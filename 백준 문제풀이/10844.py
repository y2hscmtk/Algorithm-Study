# https://www.acmicpc.net/problem/10844

'''
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.
'''

# 핵심은 좌우의 수의 차이가 1이라는 점, 그리고 0으로 시작하지 않는다는 점

n = int(input())

# 앞자리 수가 i인 n자리 계단수의 개수는 다음과 같이 표현한다
# dp[n][i]
# 이때 i는 1~9까지 가능함

# 수를 저장할 2차원 배열 작성
# n은 1보다 크고 100보다 작거나 같은 수
dp = [[0]*10 for _ in range(101)]

# 앞의 자리수가 어떤 수인지에 따라 계단수가 결정되므로
# 1자리 수의 경우 9개로 고정됨 1~9
dp[1][0] = 9

# 2자리 수의 경우 0인 경우까지 미리 기록해둔다.
for i in range(10):
    if i == 0 or i == 9:
        dp[2][i] = 1  # 0의 경우 01, 9의 경우 98만 가능하므로
    else:
        # 10,12/ 21,23 ... 등 0과 9를 앞자리 수로 갖지 않으면 2개씩 가능(+-1인 쌍이 존재하므로)
        dp[2][i] = 2


# 알고리즘 수행

# n자리 수가 될때까지 계단수 dp테이블에 작성
for i in range(3, n+1):  # 3~n자리 계단수 계산
    # 앞자리수가 될 수 있는 조건은 1~9까지의 수 => i에 대입하여 기록
    # 다음 수의 계산을 위해 앞자리수가 0인 계단수도 기록은 해둔다.
    for j in range(10):
        # 앞자리수가 0인 경위와 9인 경우는 뒤의수가 1과 8만이 가능하므로 별도로 기록한다.
        if j == 0:
            dp[i][j] = dp[i-1][1]  # 1인 경우만 가능
        elif j == 9:
            dp[i][j] = dp[i-1][8]  # 8인 경우만 가능
        else:
            # 2인 경우 1과 3이 가능(+-1인 쌍이 존재) => 오버플로우 방지를 위하여 %1000000000 하여 저장
            dp[i][j] = dp[i-1][j-1] % 1000000000 + dp[i-1][j+1] % 1000000000

if n == 1:
    print(dp[1][0])
else:
    # 결과 출력 n자리 계단수들의 합 => 앞자리 수가 0인 경우는 계단수로 취급하지 않으므로 빼준다.
    print((sum(dp[n])-dp[n][0]) % 1000000000)
