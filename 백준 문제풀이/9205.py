# https://www.acmicpc.net/problem/9205
'''
송도에 사는 상근이와 친구들은 송도에서 열리는 펜타포트 락 페스티벌에 가려고 한다. 

올해는 맥주를 마시면서 걸어가기로 했다. 출발은 상근이네 집에서 하고, 맥주 한 박스를 들고 출발한다. 

맥주 한 박스에는 맥주가 20개 들어있다. 목이 마르면 안되기 때문에 50미터에 한 병씩 마시려고 한다. 

즉, 50미터를 가려면 그 직전에 맥주 한 병을 마셔야 한다.

상근이의 집에서 페스티벌이 열리는 곳은 매우 먼 거리이다.

따라서, 맥주를 더 구매해야 할 수도 있다. 미리 인터넷으로 조사를 해보니 다행히도 맥주를 파는 편의점이 있다.

편의점에 들렸을 때, 빈 병은 버리고 새 맥주 병을 살 수 있다. 하지만, 박스에 들어있는 맥주는 20병을 넘을 수 없다. 

편의점을 나선 직후에도 50미터를 가기 전에 맥주 한 병을 마셔야 한다.

편의점, 상근이네 집, 펜타포트 락 페스티벌의 좌표가 주어진다. 

상근이와 친구들이 행복하게 페스티벌에 도착할 수 있는지 구하는 프로그램을 작성하시오.
'''
'''
상근이가 이동하는 범위는 현재위치 -> 편의점 좌표들 -> 목적지 혹은 현재위치 -> 목적지 이므로,
다른 좌표들은 고민할 필요없이, 한 정점에서 다른정점(편의점, 목적지,등)으로 이동할때 이동이 가능한지 여부만 살피면된다.(맥주의 양)
이동이 가능한지 여부는 서로 이동거리를 뺐을때, 1000(20병*50m = 1000m(한번에 이동 가능))을 초과하는지 살피면 된다.
기본 로직은 bfs로 설계하고 큐에는 편의점의 좌표들을 넣어서 방문여부를 결정하면 된다.
'''
from collections import deque
t = int(input())


def bfs(s, e):
    queue = deque()
    queue.append([s, e])

    # 편의점 개수만큼 방문정보를 확인해야하므로 배열 생성
    visited = [False for _ in range(n)]

    while queue:
        x, y = queue.popleft()
        # 현재 위치에서, 목적지에 도달하는것이 가능한지(이동거리 1000으로 이동할수 있는지) 확인
        if (abs(goal_x-x) + abs(goal_y-y)) <= 1000:
            return "happy"  # happy 리턴

        # 목적지에 아직 도달하지 못하였다면, bfs수행
        # 편의점 좌표들 하나씩 방문
        for i in range(n):
            # i번째 편의점 에 아직 방문하지 않은 경우에만 방문
            if not visited[i]:
                # 해당 편의점에 방문이 가능한지 확인(두 좌표의 차의 합이 1000이하인지 확인)
                if (abs(conveni[i][0]-x) + abs(conveni[i][1]-y)) <= 1000:
                    visited[i] = True  # 해당 편의점 방문처리
                    # 편의점의 좌표를 큐에 삽입하여, 상근이를 이동시킴
                    queue.append([conveni[i][0], conveni[i][1]])

    # 탐색 실패시 sad 리턴
    return "sad"


for _ in range(t):
    n = int(input())
    # 현재 상근이의 위치
    s, e = map(int, input().split())
    # 편의점 좌표들
    conveni = [list(map(int, input().split())) for _ in range(n)]
    # 최종 목적지
    goal_x, goal_y = map(int, input().split())
    print(bfs(s, e))
