# https://www.acmicpc.net/problem/21610
'''
크기가 N x N 인 격자가 존재하고, 각 격자의 칸에는 물을 무한대로 담을 수 있는 바구니가 존재
A[i][j]는 (i,j)좌표의 바구니에 저장된 물의 양을 의미한다.
가장 왼쪽 위 칸은 (1,1) 가장 오른쪽 아래 칸은 (N,N)이다. 
1번 행과 N번 행은 연결되어 있고, 1번 열과 N번 열도 연결되어 있다.(모듈러 연산 필요)

비바라기 시전시 (N, 1), (N, 2), (N-1, 1), (N-1, 2)에 비구름이 생긴다
이동 방향 : 1부터 순서대로 ←, ↖, ↑, ↗, →, ↘, ↓, ↙

1. 모든 구름이 di 방향으로 si칸 이동한다.
2. 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.
3. 구름이 모두 사라진다.
4. 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면, 
대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.
    - 이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.
    - 예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.
5. 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.

M번의 이동이 모두 끝난 후 바구니에 들어있는 물의 양의 합을 구하라
'''
import sys
input = sys.stdin.readline
# ←, ↖, ↑, ↗, →, ↘, ↓, ↙
dx = [0,-1,-1,-1,0,1,1,1]
dy = [-1,-1,0,1,1,1,0,-1]
N, M = map(int,input().split()) # M번의 명령을 수행한다.
A = [list(map(int,input().split())) for _ in range(N)] # 바구니의 초기 상태
move = [] # 명령 배열(방향,거리)
for _ in range(M):
    move.append(list(map(int,input().split())))
# 비바라기를 시전하면 (N,1),(N,2),(N-1,1),(N-1,2)에 비구름이 생긴다.
cloud = [(N-1,0),(N-1,1),(N-2,0),(N-2,1)] # 구름 초기 위치
for (d,s) in move: # M번의 명령을 수행한다.    
    # 1. 모든 구름이 di 방향으로 si칸 이동한다.
    for i in range(len(cloud)):
        x,y = cloud[i] # i번째 구름의 좌표
        # d방향으로 s만큼 이동 + 모듈러
        nx = (x + s*dx[d-1])%N 
        ny = (y + s*dy[d-1])%N
        cloud[i] = (nx,ny) # 구름 이동 처리
        # 2. 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.
        A[nx][ny] += 1
    # 3. 구름이 모두 사라진다
    # 4. 2에서 증가한 칸(r,c)에 물 복사버그 마법을 시전한다.
    # (r,c)에서 대각선 방향으로 거리가 1인 칸에 물이 있는 바구니 수만큼 (r,c)의 물 양이 증가한다.
    # 이때 이동과는 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.
    for r,c in cloud:
        # 현재 좌표의 대각선 방향에 대해서
        count = 0
        for nr,nc in [(r-1,c-1),(r-1,c+1),(r+1,c-1),(r+1,c+1)]:
            # 이 좌표들에 대해서는 경계를 넘어가는 칸은 고려하지 않는다.
            if 0<=nr<N and 0<=nc<N: # 경계를 넘어서지 않는다면
                if A[nr][nc] != 0:
                    count+=1
        A[r][c] += count
    # 5. 바구니에 저장된 물의 양이 2이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다.
    # 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.
    new_cloud = [] # 새로운 구름이 저장될 좌표
    # 새로운 구름은 이전에 구름이 사라진 칸이 아니어야함(cloud에 없는 값이어야 한다.)
    for i in range(N):
        for j in range(N):
            if (i,j) not in cloud:
                if A[i][j] >= 2:
                    A[i][j] -= 2 # 물의 양이 2 줄어든다.
                    new_cloud.append([i,j])
    cloud = new_cloud # 새로운 구름으로 설정

# M번의 이동이 끝난 후 바구니에 들어있는 물의 양의 합을 출력한다.
result = 0
for a in A:
    result += sum(a)
print(result)