# https://www.acmicpc.net/problem/2579

'''
계단 오르는 데는 다음과 같은 규칙이 있다.

계단은 한 번에 한 계단씩 또는 두 계단씩 오를 수 있다. 즉, 한 계단을 밟으면서 이어서 다음 계단이나, 다음 다음 계단으로 오를 수 있다.
연속된 세 개의 계단을 모두 밟아서는 안 된다. 단, 시작점은 계단에 포함되지 않는다.
마지막 도착 계단은 반드시 밟아야 한다.
따라서 첫 번째 계단을 밟고 이어 두 번째 계단이나, 세 번째 계단으로 오를 수 있다. 하지만, 첫 번째 계단을 밟고 이어 네 번째 계단으로 올라가거나, 첫 번째, 두 번째, 세 번째 계단을 연속해서 모두 밟을 수는 없다.

각 계단에 쓰여 있는 점수가 주어질 때 이 게임에서 얻을 수 있는 총 점수의 최댓값을 구하는 프로그램을 작성하시오.
'''

'''
아이디어 : dp테이블에 각 층으로 갈 수 있는 최대층수를 기록해둔다.
n층으로 갈수 있는 최대 층수를 고려할때 n번째 층은 무조건 방문해야하고
n-1층과 n-2층 둘 중 하나의 층수를 선택하는데에 과거에 몇층을 방문했는지가 미래의 층수 결정에 영향을 끼치므로
(n-1층을 선택한 경우 n-2층은 방문할 수 없고, n-2층을 선택하면 n-1층은 방문 할 수 없으므로)
영향이 가지 않는 층 수인 n-3,n-4층까지의 최대값을 고려한다.
'''

# 몇층까지 구성되어 있는지 입력받기
n = int(input())

# 해당 층수까지의 dp테이블 작성
dp = [0]*n  # n층의 결과를 얻기 위해서 dp[n-1]을 해야함

point = []  # 각 층의 점수를 기록할 배열
for _ in range(n):
    point.append(int(input()))  # 해당 층의 점수를 입력받아 저장

# 여기서 부터 알고리즘 수행
# 아래 층수부터 점수의 최대값을 기록해 나아가야 하므로 바텀업(상향식) 방식을 사용한다.
# 문제에서 주어진 조건을 통해 생각할 수 있는 점화식은 max(dp[n-4]+point[n-2]+point[n], dp[n-3]+point[n-1]+point[n])이 된다.

# 단 n-4의 값이 5보다 큰 경우에 한해서 위의 점화식을 사용할 수 있으므로 4이하의 경우는 그리디 알고리즘으로 최대값을 기록한다?

for i in range(n):
    if i == 0:  # 1층의 경우
        dp[i] = point[i]
    elif i == 1:  # 2층의 경우 => 1,2층의 점수
        dp[i] = point[i-1] + point[i]
    elif i == 2:  # 3층의 경우
        dp[i] = max(point[i-2], point[i-1]) + point[i]  # 1층 3층 vs 2층 3층
    elif i == 3:  # 4층의 경우
        dp[i] = max(point[i-3]+point[i-1], point[i-3] + point[i-2]) + point[i]
    else:  # 5층 이상의 경우
        dp[i] = max(dp[i-4] + point[i-2], dp[i-3] + point[i-1]) + point[i]
print(dp[n-1])
