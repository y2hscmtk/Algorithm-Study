# https://www.acmicpc.net/problem/6549
'''
스택 활용
1. 스택이 비어있으면 (인덱스,높이)로 스택에 삽입한다.
2. 현재 높이가 이전의 높이보다 높다면 스택에 (인덱스,높이) 형태로 삽입한다. => 가로 길이를 누적해 나아가기 위함이다.
3. 현재 높이가 이전의 높이보다 낮다면, 지금까지 스택에 쌓인 수들에 대해서 넓이 계산을 수행한다. 이후 현재 높이는 (인덱스,높이) 형태로 삽입한다.
4. 모든 결과가 끝난 후, 스택에 남아있는 수들은 오름차순일 것이다.(위의 알고리즘에 의해) 이후의 높이들에 대해서 넓이 계산을 수행한다.
넓이 계산
현재 높이 * 가로 길이(인덱스 계산)
1. 현재 높이가 마지막 높이보다 높은 경우에 대해서 낮아지거나 스택이 비기 전까지 스택에서 (인덱스,높이)를 팝한다.
2. 높이 * (마지막 높이의 인덱스 - 현재 인덱스) 공식을 통해 넓이를 갱신한다.
3. 마지막 높이보다 낮은 높이를 발견할 경우 가로를 확장 시킬 수 없으므로 중단, 중단 시점의 인덱스에서 마지막 높이와 함께 스택에 삽입한다.
(마지막 높이에 대해서는 연산에서 소모되지 않았기 때문이다.)
사용하기 좋은 예시
2 6 8 5 7 5 9 6 3
'''
import sys
input = sys.stdin.readline
while True:
    heights = list(map(int,input().split()))
    if heights[0] == 0:
        break # 마지막 입력(종료)
    heights = heights[1:] # 첫번째 입력 값은 히스토그램 정사각형의 수
    stack = []
    result = 0 # 최대 넓이 
    for i,h in enumerate(heights): # 스택 활용, 알고리즘 시작
        keep = i # 아직 사용하지 않은 높이 저장용
        while stack and stack[-1][1] > h: # 현재 높이보다 낮거나 같아질 때까지 반복(넓이 구하기)
            # 각각 수행
            # 스택에서 팝한 높이 * 인덱스 차(가로) = 넓이
            index,height = stack.pop() # 스택에서 팝한 높이, 인덱스
            result = max(result,(height*(i-index))) # 넓이 갱신
            keep = index # 저장 범위 갱신(낮아지는 순간 바로 다음에 적어도 마지막 높이 이상의 값이 있음)
        # 높이가 낮아지는 경우를 만날 경우 넓이 계산 종료, 아직 사용하지 않은 높이에 대해서 스택에 삽입
        stack.append((keep,h)) # 낮아지는 순간 바로 다음에 적어도 마지막 높이 이상의 값이 있음, 첫번째 값의 경우 바로 삽입
    # 아직 스택에 남아 있는 수들은 모두 오름차순으로 정렬되어있는 형태
    for i,h in stack:
        result = max(result,h*(len(heights)-i)) # 스택의 i번째 수이므로, 적어도 len(heights)-i개 이상은 현재 높이를 바닥에 둠
    print(result)